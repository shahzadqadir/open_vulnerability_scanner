import requests
import re
from datetime import datetime, timedelta

from .advisory import Advisory
from scanner import models


class VulnerabilityScan:
    """Vulnerability scanning using Cisco OpenVuln API.
    Needs software version of device, API Key, and API Secret to work.
    """

    def __init__(self, key: str, secret: str):
        """To use this Vulnerability Scanner, you will need to be registered with Cisco Developer Site.
        Once registered and created an API Key. Provide key and secret to initialize this class.

        Args:
            key (str): Cisco API Key
            secret (str): Cisco Client Secret
        """
        self.key = key
        self.secret = secret
        self.token = None
        self.token_expiry = datetime.now()

    def authenticate(self, client_key: str, client_secret: str) -> None:
        """Authenticates to Cisco API.

        Args:
            client_key (str): Cisco API Key
            client_secret (str): Cisco API Secret

        Raises:
            Exception: In case of error authenticating or otherwise.

        Returns:
            None: updates token info.
        """

        base_url = "https://id.cisco.com/oauth2/default/v1/token"
        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        payload = {
            "client_id": client_key,
            "client_secret": client_secret,
            "grant_type": "client_credentials",
        }
        response = requests.post(base_url, headers=headers, data=payload)
        if response.status_code == 200:
            self.token = response.json()["access_token"]
            self.token_expiry = self.token_expiry + timedelta(seconds=3600)
        else:
            raise Exception("Something went wrong. Please check your API Key & Secret.")

    def get_advisory_details(self, advisory_id: str) -> str:
        """Find details of a particular bug.

        Args:
            advisory_id (str): Cisco BugID to find details about.

        Raises:
            Exception: In case of error authenticating or otherwise.

        Returns:
            Json String format bug details data.
        """
        if self.token_expiry <= datetime.now():
            self.authenticate(self.key, self.secret)
        base_url = f"https://apix.cisco.com/security/advisories/v2/cve/{advisory_id}"
        headers = {
            "Authorization": "Bearer " + self.token,
            "Accept": "application/json",
        }
        response = requests.get(base_url, headers=headers)
        if response.status_code != 200:
            raise Exception("No bug details found.")
        return response.json()

    def get_advisory_by_software_version(
        self, software_version: str = "17.2.1", os_type: str = "iosxe"
    ) -> list:
        """Get a list of advisories for a software version.

        Args:
            software_version (str): software version to find vulnerabilities

        Returns:
            list: a list of Advisory objects
        """
        base_url = f"https://apix.cisco.com/security/advisories/v2/OSType/{os_type}?version={software_version}"
        print(base_url)

        if self.token_expiry <= datetime.now():
            self.authenticate(self.key, self.secret)
        headers = {
            "Authorization": "Bearer " + self.token,
            "Accept": "application/json",
        }
        response = requests.get(base_url, headers=headers)
        if response.status_code != 200:
            return []
        advisories = response.json()["advisories"]
        # print(advisories.keys())
        print(advisories)

        return [
            Advisory(
                advisory_id=advisory.get("advisoryId", ""),
                advisory_title=advisory.get("advisoryTitle", ""),
                bug_ids=advisory.get("bugIDs", ""),
                ips_signature=advisory.get("ipsSignatures", ""),
                cves=advisory.get("cves", ""),
                cvrf_url=advisory.get("cvrfUrl", ""),
                csaf_url=advisory.get("csafUrl", ""),
                cvss_base_score=advisory.get("cvssBaseScore", ""),
                cwe=advisory.get("cwe"),
                ios_release=advisory.get("iosRelease", ""),
                first_fixed=advisory.get("firstFixed", ""),
                first_published=advisory.get("firstPublished", ""),
                last_updated=advisory.get("lastUpdated", ""),
                status=advisory.get("status", ""),
                version=advisory.get("version", ""),
                product_names=advisory.get("productNames", ""),
                publication_url=advisory.get("publicationUrl", ""),
                sir=advisory.get("sir", ""),
                summary=advisory.get("summary", ""),
                smu=advisory.get("smu", ""),
            )
            for advisory in advisories
        ]

    def pretty_print(self, advisory: dict):
        """Creates a html file with advisory name from data in advisory

        Args:
            advisory (dict): advisory dict
        """
        filename = advisory["advisoryId"] + ".html"
        with open(filename, "w") as file:
            file.write("<html>")
            file.write("<body>")
            file.write("<table>")
            for key in advisory:
                file.write("<tr>")
                file.write(f"<td>{key}</td>")
                file.write(f"<td>{advisory[key]}</td>")
                file.write("</tr>")
            file.write("<table>")
            file.write("</body>")
            file.write("</html>")


    @staticmethod
    def insert_advisories_to_db(advisories: list, os_type: str, 
                                os_version: str) -> None:
        """Insert list of advisories into model

        Args:
            advisories (list): Vulnurabilities advisories
        """
        os = models.OS.objects.filter(os_type=os_type).filter(os_version=os_version).first()
        if not os:
            os = models.OS.objects.create(os_type=os_type, os_version=os_version)
            os.save()        

        for advisory in advisories:
            models.Advisory.objects.create(
                cisco_advisory_id = advisory.advisory_id,
                advisory_title = advisory.advisory_title,
                bug_ids = advisory.bug_ids,
                ips_signature = advisory.ips_signature,
                cves = advisory.cves,
                cvrf_url = advisory.cvrf_url,
                csaf_url = advisory.csaf_url,
                cvss_base_score = advisory.cvss_base_score,
                cwe = advisory.cwe,
                ios_release = advisory.ios_release,
                first_fixed = advisory.first_fixed,
                first_published = advisory.first_published,
                last_updated = advisory.last_updated,
                status = advisory.status,
                version = advisory.version,
                product_names = advisory.product_names,
                publication_url = advisory.publication_url,
                sir = advisory.sir,
                summary = advisory.summary,
                smu = advisory.smu,
                os = os
            )
            
                
    @classmethod
    def find_ostype_and_version(cls, show_ver: str) -> tuple:
        """Helper method, takes output of device's show version and returns
        it's os type and version.

        Args:
            show_ver (str): 'show version' command output as string

        Returns:
            tuple: (ostype, version)
        """
        ostype, version = "", ""
        ostype_result = re.findall("Cisco.*Software", show_ver)
        for line in ostype_result:
            if "xe" in line.lower():
                ostype = "iosxe"
                break
            elif "xr" in line.lower():
                ostype = "iosxr"
                break
            elif "nx" in line.lower():
                ostype = "nxos"
                break
            else:
                ostype = "ios"
        if ostype == "nxos":
            version_result = re.findall(r"NXOS: version [\d, '.', \(, \)]*", show_ver)
            version = version_result[0].split()[2].strip()
        else:
            version_result = re.findall(
                r"Version[\d, '.', \(, \)]*[a-zA-Z0-9]*", show_ver
            )
            version = version_result[0].split()[1].strip(".")
        return (ostype, version)
    
            
